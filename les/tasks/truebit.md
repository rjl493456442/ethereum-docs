You can run TrueBit verification games for C/C++ code on both Kovan and Rinkeby testnets, and we welcome you to test our code!  Please start with this Docker container:

https://github.com/TrueBitFoundation/test-node-docker

We have a VM that is based on WASM, there are some changes to make it easier to interpret.
Here is some documentation: https://github.com/TrueBitFoundation/ocaml-offchain/wiki/Initializing-and-preprocessing-WebAssembly

Currently, the code will have to be written C/C++, or Rust, and for output and input ,the program has to read and write to files.
In the blockchain, the files are identified by their binary merkle roots. So for example if one would like to calculate a sha256 hash of a large file, then the task would have the merkle root of the file as an argument. But if the merkle root is nonsense, and somebody posts a bad solution, there is no efficient way to disprove the  (data availability problem). So there might be some problems with checking data that is available in the blockchain, if it is not in the correct format. I think that we will have to add some way to add custom instructions to the VM to solve this.

Probably the best way to start would be to have the programs working in C, and compiling them into wasm with emscripten. I'm currently working on the pipeline for generating a verifiable task from the wasm file generated by emscripten, the old version is at https://github.com/TrueBitFoundation/emscripten-module-wrapper ... The judge contract is at https://github.com/TrueBitFoundation/webasm-solidity/tree/master/contracts

Here is a short description of up-to-date files
* tasks.sol: contract for posting tasks
* fs.sol: file system, this is needed for constructing the input and output for the tasks
* interactive2.sol: interactive proofs, this is called from tasks.sol in case of dispute
* vmmemory.sol: some helpers for handling the memory, inherited in alu.sol
* alu.sol: handling arithmetic and other computations
* onchain.sol: handling merkle proofs
* offchain: same as onchain.sol, but can be used for off-chain computation of the VM, just linear memory instead of merkle proofs
* common.sol: handling the computation steps. each instruction is executed in several places
* judge.sol: entry point for validating a computation step, called by interactive2.sol when the binary search has found the correct position. judge method is the main entry point for validating a single step